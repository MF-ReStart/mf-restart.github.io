
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>配置 · 荒原饮露的笔记</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.1.6">
        <meta name="author" content="荒原饮露">
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="statefulset.html" />
    
    
    <link rel="prev" href="storage.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">简介</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                        <b>1.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Kubernetes</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="readme.html">
            
                <a href="readme.html">
            
                    
                        <b>2.1.</b>
                    
                    Kubernetes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="overview.html">
            
                <a href="overview.html">
            
                    
                        <b>2.1.1.</b>
                    
                    概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="deployment-kubernetes-cluster.html">
            
                <a href="deployment-kubernetes-cluster.html">
            
                    
                        <b>2.1.2.</b>
                    
                    部署Kubernetes集群
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="kubelet-overview.html">
            
                <a href="kubelet-overview.html">
            
                    
                        <b>2.1.3.</b>
                    
                    Kubelet概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="object-resource-format.html">
            
                <a href="object-resource-format.html">
            
                    
                        <b>2.1.4.</b>
                    
                    对象类资源格式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="workload-resources.html">
            
                <a href="workload-resources.html">
            
                    
                        <b>2.1.5.</b>
                    
                    工作负载资源使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="service-resources.html">
            
                <a href="service-resources.html">
            
                    
                        <b>2.1.6.</b>
                    
                    Service资源
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.7" data-path="ingress.html">
            
                <a href="ingress.html">
            
                    
                        <b>2.1.7.</b>
                    
                    Ingress
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.8" data-path="storage.html">
            
                <a href="storage.html">
            
                    
                        <b>2.1.8.</b>
                    
                    存储
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.1.9" data-path="configuration.html">
            
                <a href="configuration.html">
            
                    
                        <b>2.1.9.</b>
                    
                    配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.10" data-path="statefulset.html">
            
                <a href="statefulset.html">
            
                    
                        <b>2.1.10.</b>
                    
                    StatefulSet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.11" data-path="certification-authorization-access-control.html">
            
                <a href="certification-authorization-access-control.html">
            
                    
                        <b>2.1.11.</b>
                    
                    认证授权与准入控制
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Docker</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../docker/readme.html">
            
                <a href="../docker/readme.html">
            
                    
                        <b>3.1.</b>
                    
                    Docker
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="../docker/overview.html">
            
                <a href="../docker/overview.html">
            
                    
                        <b>3.1.1.</b>
                    
                    概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="../docker/install.html">
            
                <a href="../docker/install.html">
            
                    
                        <b>3.1.2.</b>
                    
                    安装
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="../docker/images-and-containers.html">
            
                <a href="../docker/images-and-containers.html">
            
                    
                        <b>3.1.3.</b>
                    
                    镜像和容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="../docker/data-persistence.html">
            
                <a href="../docker/data-persistence.html">
            
                    
                        <b>3.1.4.</b>
                    
                    数据持久化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="../docker/network.html">
            
                <a href="../docker/network.html">
            
                    
                        <b>3.1.5.</b>
                    
                    网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.6" data-path="../docker/dockerfile.html">
            
                <a href="../docker/dockerfile.html">
            
                    
                        <b>3.1.6.</b>
                    
                    Dockerfile
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">MySql</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../mysql/readme.html">
            
                <a href="../mysql/readme.html">
            
                    
                        <b>4.1.</b>
                    
                    MySql
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../mysql/mysql-base.html">
            
                <a href="../mysql/mysql-base.html">
            
                    
                        <b>4.1.1.</b>
                    
                    基础
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">笔记</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../../life/dream.html">
            
                <a href="../../life/dream.html">
            
                    
                        <b>5.1.</b>
                    
                    Dream
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >配置</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="配置">配置</h1>
<p>此模块整合了 Kubernetes 所有资源的配置。</p>
<h2 id="配置最佳实践">配置最佳实践</h2>
<p><a href="https://kubernetes.io/zh/docs/concepts/configuration/overview/" target="_blank">https://kubernetes.io/zh/docs/concepts/configuration/overview/</a></p>
<h2 id="configmap">ConfigMap</h2>
<p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank">Pods</a> 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</p>
<p>ConfigMap 将您的环境配置信息和 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image" target="_blank">容器镜像</a> 解耦，便于应用配置的修改。</p>
<blockquote>
<p>注意：ConfigMap 并不提供保密或者加密功能。 如果你想存储的数据是机密的，请使用 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/" target="_blank">Secret</a>， 或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。</p>
</blockquote>
<h3 id="动机">动机</h3>
<p>使用 ConfigMap 来将你的配置数据和应用程序代码分开。</p>
<p>比如，假设你正在开发一个应用，它可以在你自己的电脑上（用于开发）和在云上 （用于实际流量）运行。 你的代码里有一段是用于查看环境变量 <code>DATABASE_HOST</code>，在本地运行时， 你将这个变量设置为 <code>localhost</code>，在云上，你将其设置为引用 Kubernetes 集群中的公开数据库组件的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank">服务</a>。</p>
<p>这让你可以获取在云中运行的容器镜像，并且如果有需要的话，在本地调试完全相同的代码。</p>
<p>ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。如果你需要保存超出此尺寸限制的数据，你可能希望考虑挂载存储卷或者使用独立的数据库或者文件服务。</p>
<h3 id="configmap-对象">ConfigMap 对象</h3>
<p>ConfigMap 是一个 API <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank">对象</a>， 让你可以存储其他对象所需要使用的配置。 和其他 Kubernetes 对象都有一个 <code>spec</code> ，不同的是，ConfigMap 使用 <code>data</code> 和 <code>binaryData</code> 字段。这些字段能够接收键-值对作为其取值。<code>data</code> 和 <code>binaryData</code> 字段都是可选的。<code>data</code> 字段设计用来保存 UTF-8 字节序列，而 <code>binaryData</code> 则被设计用来保存二进制数据作为 base64 编码的字串。</p>
<p>ConfigMap 的名字必须是一个合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank">DNS 子域名</a>。</p>
<p><code>data</code> 或 <code>binaryData</code> 字段下面的每个键的名称都必须由字母数字字符或者 <code>-</code>、<code>_</code> 或 <code>.</code> 组成。在 <code>data</code> 下保存的键名不可以与在 <code>binaryData</code> 下出现的键名有重叠。</p>
<p>从 v1.19 开始，你可以添加一个 <code>immutable</code> 字段到 ConfigMap 定义中，创建 <a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/#configmap-immutable" target="_blank">不可变更的 ConfigMap</a>。</p>
<h3 id="configmaps-和-pods">ConfigMaps 和 Pods</h3>
<p>你可以写一个引用 ConfigMap 的 Pod 的 <code>spec</code>，并根据 ConfigMap 中的数据在该 Pod 中配置容器。这个 Pod 和 ConfigMap 必须要在同一个 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/" target="_blank">名字空间</a> 中。</p>
<p>这是一个 ConfigMap 的示例，它的一些键只有一个值，其他键的值看起来像是配置的片段格式。</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-demo</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-comment"># 类属性键:每一个键都映射到一个简单的值</span>
  <span class="hljs-attr">nginx_server_port:</span> <span class="hljs-string">"80"</span>
  <span class="hljs-attr">nginx_server_host:</span> <span class="hljs-string">"www.missf.top"</span>

  <span class="hljs-comment"># 类文件键</span>
  <span class="hljs-attr">nginx.config:</span> <span class="hljs-string">|
    location / {
        root /usr/local/nginx/html/;
        index index.html;
    }
</span></code></pre>
<p>你可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：</p>
<ol>
<li>在容器命令和参数内。</li>
<li>容器的环境变量。</li>
<li>在只读卷里面添加一个文件，让应用来读取。</li>
<li>编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap。</li>
</ol>
<p>这些不同的方法适用于不同的数据使用方式。 对前三个方法，<a href="https://kubernetes.io/docs/reference/generated/kubelet" target="_blank">kubelet</a> 使用 ConfigMap 中的数据在 Pod 中启动容器。</p>
<p>第四种方法意味着你必须编写代码才能读取 ConfigMap 和它的数据。然而， 由于你是直接使用 Kubernetes API，因此只要 ConfigMap 发生更改，你的应用就能够通过订阅来获取更新，并且在这样的情况发生的时候做出反应。 通过直接进入 Kubernetes API，这个技术也可以让你能够获取到不同的名字空间里的 ConfigMap。</p>
<p>下面是一个 Pod 的示例，它通过使用 <code>configmap-demo</code> 中的值来配置一个 Pod:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-pod</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">configmap</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
    <span class="hljs-attr">env:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NGINX_SERVER_PORT</span>
        <span class="hljs-attr">valueFrom:</span>
          <span class="hljs-attr">configMapKeyRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-demo</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">nginx_server_port</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NGINX_SERVER_HOST</span>
        <span class="hljs-attr">valueFrom:</span>
          <span class="hljs-attr">configMapKeyRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-demo</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">nginx_server_host</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/config"</span>
      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-demo</span>
        <span class="hljs-attr">items:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">"nginx.config"</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">"nginx.config"</span>
</code></pre>
<p>ConfigMap 不会区分单行属性值和多行类似文件的值，重要的是 Pods 和其他对象如何使用这些值。（能否自动更新也是看 Pods 如何去使用 ConfigMap）。</p>
<p>上面的例子定义了一个卷并将它作为 <code>/config</code> 文件夹挂载到 <code>demo</code> 容器内， 创建一个文件，<code>/config/nginx.config</code>。</p>
<h3 id="使用-configmap">使用 ConfigMap</h3>
<p>ConfigMap 可以作为数据卷挂载。ConfigMap 也可被系统的其他组件使用，而不一定直接暴露给 Pod。例如，ConfigMap 可以保存系统中其他组件要使用的配置数据。</p>
<p>ConfigMap 最常见的用法是为同一命名空间里某 Pod 中运行的容器执行配置。 你也可以单独使用 ConfigMap。</p>
<p>比如，你可能会遇到基于 ConfigMap 来调整其行为的 <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank">插件</a> 或者 <a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/" target="_blank">operator</a>。</p>
<h4 id="在-pod-中将-configmap-当做文件使用">在 Pod 中将 ConfigMap 当做文件使用</h4>
<ol>
<li>创建一个 ConfigMap 对象或者使用现有的 ConfigMap 对象。多个 Pod 可以引用同一个 ConfigMap。</li>
<li>修改 Pod 定义，在 <code>spec.volumes[]</code> 下添加一个卷。 为该卷设置任意名称，之后将 <code>spec.volumes[].configMap.name</code> 字段设置为对你的 ConfigMap 对象的引用。</li>
<li>为每个需要该 ConfigMap 的容器添加一个 <code>.spec.containers[].volumeMounts[]</code>。 设置 <code>.spec.containers[].volumeMounts[].readOnly=true</code> 并将 <code>.spec.containers[].volumeMounts[].mountPath</code> 设置为一个未使用的目录名， ConfigMap 的内容将出现在该目录中。</li>
<li>更改你的镜像或者命令行，以便程序能够从该目录中查找文件。ConfigMap 中的每个 <code>data</code> 键会变成 <code>mountPath</code> 下面的一个文件名。</li>
</ol>
<p>下面是一个将 ConfigMap 以卷的形式进行挂载的 Pod 示例：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/etc/foo"</span>
      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span>
    <span class="hljs-attr">configMap:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">myconfigmap</span>
</code></pre>
<p>你希望使用的每个 ConfigMap 都需要在 <code>spec.volumes</code> 中被引用到。</p>
<p>如果 Pod 中有多个容器，则每个容器都需要自己的 <code>volumeMounts</code> 块，但针对每个 ConfigMap，你只需要设置一个 <code>spec.volumes</code> 块。</p>
<h4 id="被挂载的-configmap-内容会被自动更新">被挂载的 ConfigMap 内容会被自动更新</h4>
<p>当卷中使用的 ConfigMap 被更新时，所投射的键最终也会被更新。 kubelet 组件会在每次周期性同步时检查所挂载的 ConfigMap 是否为最新。 不过，kubelet 使用的是其本地的高速缓存来获得 ConfigMap 的当前值。 高速缓存的类型可以通过 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go" target="_blank">KubeletConfiguration 结构</a> 的 <code>ConfigMapAndSecretChangeDetectionStrategy</code> 字段来配置。</p>
<p>ConfigMap 既可以通过 watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一 时间跨度可能与 kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型 （分别对应 watch 操作的传播延迟、高速缓存的 TTL 时长或者 0）。</p>
<p>以环境变量方式使用的 ConfigMap 数据不会被自动更新。 更新这些数据需要重新启动 Pod。</p>
<h3 id="不可变更的-configmap">不可变更的 ConfigMap</h3>
<p>Kubernetes 不可变更的 Secret 和 ConfigMap 提供了一种将各个 Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群（至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改 ConfigMap 的数据有以下好处：</p>
<ul>
<li>保护应用，使之免受意外（不想要的）更新所带来的负面影响。</li>
<li>通过大幅降低对 kube-apiserver 的压力提升集群性能，这是因为系统会关闭对已标记为不可变更的 ConfigMap 的监视操作。</li>
</ul>
<p>此功能特性由 <code>ImmutableEphemeralVolumes</code> <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/feature-gates/" target="_blank">特性门控</a> 来控制。你可以通过将 <code>immutable</code> 字段设置为 <code>true</code> 创建不可变更的 ConfigMap。 例如：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-string">...</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-string">...</span>
<span class="hljs-attr">immutable:</span> <span class="hljs-literal">true</span>
</code></pre>
<p>一旦某 ConfigMap 被标记为不可变更，则无法逆转这一变化，也无法更改 <code>data</code> 或 <code>binaryData</code> 字段的内容。你只能删除并重建 ConfigMap。 因为现有的 Pod 会维护一个对已删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。</p>
<h2 id="secret">Secret</h2>
<p><code>Secret</code> 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 <code>secret</code> 中比放在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank">Pod</a> 的定义或者 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image" target="_blank">容器镜像</a> 中来说更加安全和灵活。 参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md" target="_blank">Secret 设计文档</a> 获取更多详细信息。</p>
<p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 用户可以创建 Secret，同时系统也创建了一些 Secret。</p>
<p><strong>注意：</strong>Kubernetes Secret 默认情况下存储为 base64-编码的、非加密的字符串。 默认情况下，能够访问 API 的任何人，或者能够访问 Kubernetes 下层数据存储（etcd） 的任何人都可以以明文形式读取这些数据。 为了能够安全地使用 Secret，我们建议你（至少）：</p>
<ol>
<li>为 Secret <a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/" target="_blank">启用静态加密</a>；</li>
<li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authorization/" target="_blank">启用或配置 RBAC 规则</a>来限制对 Secret 的读写操作。 要注意，任何被允许创建 Pod 的人都默认地具有读取 Secret 的权限。</li>
</ol>
<h3 id="secret-概览">Secret 概览</h3>
<p>要使用 Secret，Pod 需要引用 Secret。 Pod 可以用三种方式之一来使用 Secret:</p>
<ul>
<li>作为挂载到一个或多个容器上的 <a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/" target="_blank">卷</a> 中的<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod" target="_blank">文件</a>。</li>
<li>作为<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-secrets-as-environment-variables" target="_blank">容器的环境变量</a></li>
<li>由 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-imagepullsecrets" target="_blank">kubelet 在为 Pod 拉取镜像时使用</a></li>
</ul>
<p>Secret 对象的名称必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank">DNS 子域名</a>。 在为创建 Secret 编写配置文件时，你可以设置 <code>data</code> 与/或 <code>stringData</code> 字段。 <code>data</code> 和 <code>stringData</code> 字段都是可选的。<code>data</code> 字段中所有键值都必须是 base64 编码的字符串。如果不希望执行这种 base64 字符串的转换操作，你可以选择设置 <code>stringData</code> 字段，其中可以使用任何字符串作为其取值。</p>
<h3 id="secret-的类型">Secret 的类型</h3>
<p>在创建 Secret 对象时，你可以使用 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#secret-v1-core" target="_blank"><code>Secret</code></a> 资源的 <code>type</code> 字段，或者与其等价的 <code>kubectl</code> 命令行参数（如果有的话）为其设置类型。 Secret 的类型用来帮助编写程序处理 Secret 数据。</p>
<p>Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。</p>
<table>
<thead>
<tr>
<th>内置类型</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Opaque</code></td>
<td>用户定义的任意数据</td>
</tr>
<tr>
<td><code>kubernetes.io/service-account-token</code></td>
<td>服务账号令牌</td>
</tr>
<tr>
<td><code>kubernetes.io/dockercfg</code></td>
<td><code>~/.dockercfg</code> 文件的序列化形式</td>
</tr>
<tr>
<td><code>kubernetes.io/dockerconfigjson</code></td>
<td><code>~/.docker/config.json</code> 文件的序列化形式</td>
</tr>
<tr>
<td><code>kubernetes.io/basic-auth</code></td>
<td>用于基本身份认证的凭据</td>
</tr>
<tr>
<td><code>kubernetes.io/ssh-auth</code></td>
<td>用于 SSH 身份认证的凭据</td>
</tr>
<tr>
<td><code>kubernetes.io/tls</code></td>
<td>用于 TLS 客户端或者服务器端的数据</td>
</tr>
<tr>
<td><code>bootstrap.kubernetes.io/token</code></td>
<td>启动引导令牌数据</td>
</tr>
</tbody>
</table>
<p>通过为 Secret 对象的 <code>type</code> 字段设置一个非空的字符串值，你也可以定义并使用自己 Secret 类型。如果 <code>type</code> 值为空字符串，则被视为 <code>Opaque</code> 类型。 Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。</p>
<h3 id="创建-secret">创建 Secret</h3>
<p>有几种不同的方式来创建 Secret:</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/" target="_blank">使用 <code>kubectl</code> 命令创建 Secret</a></p>
<p>一个 <code>Secret</code> 可以包含 Pod 访问数据库所需的用户凭证。 例如，由用户名和密码组成的数据库连接字符串。 你可以在本地计算机上，将用户名存储在文件 <code>./username.txt</code> 中，将密码存储在文件 <code>./password.txt</code> 中。</p>
<pre><code class="lang-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">'admin'</span> &gt; ./username.txt
<span class="hljs-built_in">echo</span> -n <span class="hljs-string">'Er34ff5ghoo'</span> &gt; ./password.txt
</code></pre>
<p>在这些命令中，<code>-n</code> 标志确保生成的文件在文本末尾不包含额外的换行符。 这一点很重要，因为当 <code>kubectl</code> 读取文件并将内容编码为 base64 字符串时，多余的换行符也会被编码。</p>
<p><code>kubectl create secret</code> 命令将这些文件打包成一个 Secret 并在 API 服务器上创建对象。</p>
<pre><code class="lang-bash">kubectl create secret generic db-user-pass --from-file=user=username.txt --from-file=pass=password.txt
</code></pre>
<p>输出类似于：</p>
<pre><code class="lang-bash">secret/db-user-pass created
</code></pre>
<p>默认密钥名称是文件名。 你可以选择使用 <code>--from-file=[key=]source</code> 来设置密钥名称。例如：</p>
<pre><code class="lang-bash">kubectl create secret generic db-user-pass \
  --from-file=username=./username.txt \
  --from-file=password=./password.txt
</code></pre>
<p>检查 secret 是否已创建：</p>
<pre><code class="lang-bash">kubectl get secrets
</code></pre>
<p>你可以查看 <code>Secret</code> 的描述：</p>
<pre><code class="lang-bash">kubectl describe secrets/db-user-pass
</code></pre>
<p>要查看创建的 Secret 的内容，运行以下命令：</p>
<pre><code class="lang-bash">kubectl get secret db-user-pass -o jsonpath=<span class="hljs-string">'{.data}'</span>
</code></pre>
<p>输出类似于：</p>
<pre><code class="lang-json">{<span class="hljs-string">"pass"</span>:<span class="hljs-string">"RXIzNGZmNWdob28="</span>,<span class="hljs-string">"user"</span>:<span class="hljs-string">"YWRtaW4="</span>}
</code></pre>
<p>现在你可以解码 <code>pass</code> 的数据：</p>
<pre><code class="lang-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"RXIzNGZmNWdob28="</span> | <span class="hljs-built_in">base64</span> --decode
</code></pre>
<p>输出类似于：</p>
<pre><code class="lang-bash">Er34ff5ghoo
</code></pre>
<p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-config-file/" target="_blank">使用配置文件来创建 Secret</a></p>
<p>你可以先用 JSON 或 YAML 格式在文件中创建 Secret，然后创建该对象。 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#secret-v1-core" target="_blank">Secret</a> 资源包含2个键值对： <code>data</code> 和 <code>stringData</code>。 <code>data</code> 字段用来存储 base64 编码的任意数据。 提供 <code>stringData</code> 字段是为了方便，它允许 Secret 使用未编码的字符串。 <code>data</code> 和 <code>stringData</code> 的键必须由字母、数字、<code>-</code>，<code>_</code> 或 <code>.</code> 组成。</p>
<p>例如，要使用 Secret 的 <code>data</code> 字段存储两个字符串，请将字符串转换为 base64 ，如下所示：</p>
<pre><code class="lang-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">'admin'</span> | <span class="hljs-built_in">base64</span>
<span class="hljs-built_in">echo</span> -n <span class="hljs-string">'Er34ff5ghoo'</span> | <span class="hljs-built_in">base64</span>
</code></pre>
<p>输出类似于：</p>
<pre><code class="lang-bash">YWRtaW4=
RXIzNGZmNWdob28=
</code></pre>
<p>编写一个 Secret 配置文件，如下所示：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">username:</span> <span class="hljs-string">YWRtaW4=</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">RXIzNGZmNWdob28=</span>
</code></pre>
<p>对于某些场景，你可能希望使用 <code>stringData</code> 字段。 这字段可以将一个非 base64 编码的字符串直接放入 Secret 中， 当创建或更新该 Secret 时，此字段将被编码。</p>
<p>例如，如果你的应用程序使用以下配置文件：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiUrl:</span> <span class="hljs-string">"https://my.api.com/api/v1"</span>
<span class="hljs-attr">username:</span> <span class="hljs-string">"&lt;user&gt;"</span>
<span class="hljs-attr">password:</span> <span class="hljs-string">"&lt;password&gt;"</span>
</code></pre>
<p>你可以使用以下定义将其存储在 Secret 中：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>
<span class="hljs-attr">stringData:</span>
  <span class="hljs-attr">config.yaml:</span> <span class="hljs-string">|
    apiUrl: "https://my.api.com/api/v1"
    username: &lt;user&gt;
    password: &lt;password&gt;
</span></code></pre>
<p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kustomize/" target="_blank">使用 kustomize 来创建 Secret</a></p>
<p>你可以在 <code>kustomization.yaml</code> 中定义 <code>secreteGenerator</code>，并在定义中引用其他现成的文件，生成 Secret。 例如：下面的 kustomization 文件 引用了 <code>./username.txt</code> 和 <code>./password.txt</code> 文件：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">secretGenerator:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">db-user-pass</span>
  <span class="hljs-attr">files:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">username.txt</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">password.txt</span>
</code></pre>
<p>你也可以在 <code>kustomization.yaml</code> 文件中指定一些字面量定义 <code>secretGenerator</code>。 例如：下面的 <code>kustomization.yaml</code> 文件中包含了 <code>username</code> 和 <code>password</code> 两个字面量：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">secretGenerator:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">db-user-pass</span>
  <span class="hljs-attr">literals:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">username=admin</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">password=1f2d1e2e67df</span>
</code></pre>
<p>注意，上面两种情况，你都不需要使用 base64 编码。</p>
<p>使用 <code>kubectl apply</code> 命令应用包含 <code>kustomization.yaml</code> 文件的目录创建 Secret。</p>
<pre><code class="lang-bash">kubectl apply -k .
</code></pre>
<h3 id="编辑-secret">编辑 Secret</h3>
<p>你可以通过下面的命令编辑现有的 Secret:</p>
<pre><code class="lang-bash">kubectl edit secrets mysecret
</code></pre>
<h3 id="使用-secret">使用 Secret</h3>
<p>Secret 可以作为数据卷被挂载，或作为 <a href="https://kubernetes.io/zh/docs/concepts/containers/container-environment/" target="_blank">环境变量</a> 暴露出来以供 Pod 中的容器使用。它们也可以被系统的其他部分使用，而不直接暴露在 Pod 内。 例如，它们可以保存凭据，系统的其他部分将用它来代表你与外部系统进行交互。</p>
<p>将 Secret 作为 Pod 中的<a href="https://kubernetes.io/zh/docs/concepts/containers/container-environment/" target="_blank">环境变量</a>使用：</p>
<ol>
<li>创建一个 Secret 或者使用一个已存在的 Secret。多个 Pod 可以引用同一个 Secret。</li>
<li>修改 Pod 定义，为每个要使用 Secret 的容器添加对应 Secret 键的环境变量。 使用 Secret 键的环境变量应在 <code>env[x].valueFrom.secretKeyRef</code> 中指定要包含的 Secret 名称和键名。</li>
<li>更改镜像并／或者命令行，以便程序在指定的环境变量中查找值。</li>
</ol>
<p>这是一个使用来自环境变量中的 Secret 值的 Pod 示例：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-env-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">env:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SECRET_USERNAME</span>
        <span class="hljs-attr">valueFrom:</span>
          <span class="hljs-attr">secretKeyRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">username</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SECRET_PASSWORD</span>
        <span class="hljs-attr">valueFrom:</span>       
          <span class="hljs-attr">secretKeyRef:</span>  
            <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">password</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
</code></pre>
<p>在 Pod 中使用存放在卷中的 Secret:</p>
<ol>
<li>创建一个 Secret 或者使用已有的 Secret。多个 Pod 可以引用同一个 Secret。</li>
<li>修改你的 Pod 定义，在 <code>spec.volumes[]</code> 下增加一个卷。可以给这个卷随意命名， 它的 <code>spec.volumes[].secret.secretName</code> 必须是 Secret 对象的名字。</li>
<li>将 <code>spec.containers[].volumeMounts[]</code> 加到需要用到该 Secret 的容器中。 指定 <code>spec.containers[].volumeMounts[].readOnly = true</code> 和 <code>spec.containers[].volumeMounts[].mountPath</code> 为你想要该 Secret 出现的尚未使用的目录。</li>
<li>修改你的镜像并且／或者命令行，让程序从该目录下寻找文件。 Secret 的 <code>data</code> 映射中的每一个键都对应 <code>mountPath</code> 下的一个文件名。</li>
</ol>
<p>这是一个在 Pod 中使用存放在挂载卷中 Secret 的例子：</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/etc/foo"</span>
      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span>
    <span class="hljs-attr">secret:</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">mysecret</span>
</code></pre>
<h3 id="挂载的-secret-会被自动更新">挂载的 Secret 会被自动更新</h3>
<p>当已经存储于卷中被使用的 Secret 被更新时，被映射的键也将被更新。 组件 kubelet 在周期性同步时检查被挂载的 Secret 是不是最新的。 但是，它会使用其本地缓存的数值作为 Secret 的当前值。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="storage.html" class="navigation navigation-prev " aria-label="Previous page: 存储">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="statefulset.html" class="navigation navigation-next " aria-label="Next page: StatefulSet">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"配置","level":"2.1.9","depth":2,"next":{"title":"StatefulSet","level":"2.1.10","depth":2,"path":"worknote/kubernetes/statefulset.md","ref":"worknote/kubernetes/statefulset.md","articles":[]},"previous":{"title":"存储","level":"2.1.8","depth":2,"path":"worknote/kubernetes/storage.md","ref":"worknote/kubernetes/storage.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","-sharing","search-plus","github","expandable-chapters"],"root":".","styles":{"website":"styles/website.css"},"pluginsConfig":{"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"github":{"url":"https://github.com/MF-ReStart/mf-restart.github.io"},"search-plus":{},"expandable-chapters":{},"highlight":{},"fontsettings":{"theme":"white","family":"sans","size":2}},"theme":"default","author":"荒原饮露","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"荒原饮露的笔记","language":"zh-hans","gitbook":"*","description":"记录工作和生活"},"file":{"path":"worknote/kubernetes/configuration.md","mtime":"2026-01-30T01:33:18.792Z","type":"markdown"},"gitbook":{"version":"6.1.6","time":"2026-01-30T02:42:25.515Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

