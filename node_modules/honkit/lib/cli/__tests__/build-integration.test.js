"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const bin_1 = require("../../bin");
const internal_test_utils_1 = require("@honkit/internal-test-utils");
/**
 * Integration tests for honkit build output
 *
 * These tests use bin.run to execute the CLI and verify:
 * 1. New files added to SUMMARY.md are correctly generated
 * 2. Assets not in SUMMARY.md are copied correctly
 * 3. Output structure matches expected snapshot
 *
 * This is a black-box test that only checks input (book files) and output (generated files).
 */
jest.setTimeout(60000);
describe("build integration", () => {
    let tempDir;
    let outputDir;
    beforeEach(() => {
        tempDir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), "honkit-build-test-"));
        outputDir = path_1.default.join(tempDir, "_book");
    });
    afterEach(() => {
        if (tempDir && fs_1.default.existsSync(tempDir)) {
            fs_1.default.rmSync(tempDir, { recursive: true, force: true });
        }
    });
    function createBookStructure() {
        fs_1.default.writeFileSync(path_1.default.join(tempDir, "README.md"), `# Test Book

Welcome to the test book.
`);
        fs_1.default.writeFileSync(path_1.default.join(tempDir, "SUMMARY.md"), `# Summary

* [Introduction](README.md)
`);
    }
    async function buildBook() {
        await (0, bin_1.run)([process.argv[0], "honkit", "build", tempDir, outputDir, "--reload"]);
    }
    function getOutputFiles() {
        if (!fs_1.default.existsSync(outputDir))
            return [];
        const files = [];
        const walk = (dir, prefix = "") => {
            const entries = fs_1.default.readdirSync(dir, { withFileTypes: true });
            for (const entry of entries) {
                const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;
                if (entry.isDirectory()) {
                    walk(path_1.default.join(dir, entry.name), relativePath);
                }
                else {
                    files.push(relativePath);
                }
            }
        };
        walk(outputDir);
        return files.sort();
    }
    describe("build output with bin.run", () => {
        it("should generate index.html for README.md", async () => {
            createBookStructure();
            await buildBook();
            const files = getOutputFiles();
            expect(files).toContain("index.html");
        });
        it("should generate chapter page when added to SUMMARY.md", async () => {
            createBookStructure();
            // Add chapter
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "chapter1.md"), `# Chapter 1

This is chapter 1.
`);
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "SUMMARY.md"), `# Summary

* [Introduction](README.md)
* [Chapter 1](chapter1.md)
`);
            await buildBook();
            const files = getOutputFiles();
            expect(files).toContain("index.html");
            expect(files).toContain("chapter1.html");
        });
        it("should copy asset file not in SUMMARY.md", async () => {
            createBookStructure();
            // Add asset file (not in SUMMARY)
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "notes.md"), `# Notes

These are my notes.
`);
            await buildBook();
            const files = getOutputFiles();
            expect(files).toContain("index.html");
            expect(files).toContain("notes.md"); // Copied as asset
        });
        it("should match expected output structure", async () => {
            createBookStructure();
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "chapter1.md"), `# Chapter 1

Content of chapter 1.
`);
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "SUMMARY.md"), `# Summary

* [Introduction](README.md)
* [Chapter 1](chapter1.md)
`);
            await buildBook();
            const files = getOutputFiles();
            // Filter out gitbook files and search index for cleaner snapshot
            const relevantFiles = files.filter((f) => !f.startsWith("gitbook/") && !f.includes("search_index") && !f.includes("lunr"));
            expect(relevantFiles).toMatchSnapshot("output-structure");
        });
        it("should generate correct HTML content", async () => {
            createBookStructure();
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "chapter1.md"), `# Chapter 1

Content of chapter 1.
`);
            fs_1.default.writeFileSync(path_1.default.join(tempDir, "SUMMARY.md"), `# Summary

* [Introduction](README.md)
* [Chapter 1](chapter1.md)
`);
            await buildBook();
            // Use iterateDirectoryContents like snapshot-honkit.ts
            const maskContent = (content) => {
                return content
                    .replace(/gitbook\.page\.hasChanged\(.*\);/g, "")
                    .replace(/<meta name="generator" content="HonKit .*">/g, "")
                    .replace(tempDir, "<TEMP_DIR>");
            };
            for await (const item of (0, internal_test_utils_1.iterateDirectoryContents)({
                baseDir: outputDir,
                allowExtensions: [".html"],
                maskContent
            })) {
                // Only snapshot key pages, not all gitbook assets
                if (item.filePath === "index.html" || item.filePath === "chapter1.html") {
                    expect(item).toMatchSnapshot(item.filePath);
                }
            }
        });
    });
});
